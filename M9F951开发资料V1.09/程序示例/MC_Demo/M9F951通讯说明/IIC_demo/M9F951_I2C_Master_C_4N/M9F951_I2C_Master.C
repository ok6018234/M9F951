/*******************(C) COPYRIGHT 2021 Masses-Chip ****************************
* Project Name       : M9F951_I2C Master.prj
* File Name          : M9F951_I2C_Master.C
* Author             : MASSES CHIP
* Version            : V2.00
* Date               : 2021/09/15
* Web    			 : www.masses-chip.com
* FAE				 : Luo
*  				 	 : QQ：411680975
*******************************************************************************
*Option:16M/16T,WDT-Enable-288ms,RST-IO,BOR 2.4V 
*说明：本范例为IIC主机模式，数据线SDA0(IOF5)、时钟线SCL0(IOF6)；
*包括主机的写与读操作，从机器件地址为0x20
*主机在从机RAM区0x20开始写入数据0x55、0xAA、0xFF，
*主机读取从机的数据在RAM区0x20开始存放
******************************************************************************/
//=============================================================================
//*******************************头文件和调用申明******************************
//=============================================================================
//用户不可更改
#include "zc.h"
#include "MASSESCHIP_DEFINE.H"


//-----------------------------------------------------------------------------
//用户可以自行更改
void SYSTEM_INIT(void);						//系统初始化
void I2C_Master_INIT(void);					//I2C主机初始化
void Delay(void);							//延时
void I2C_Master_Write(void);				//主机写
void I2C_Send_Data(unsigned char R_Data);	//I2C主机发送数据
void I2C_Master_Read(void);					//主机读


//-----------------------------------------------------------------------------
//定义变量
unsigned char R_Temp;						//存储接收的最后一个字节数据
unsigned char IIC_RBUF[20]	@(0x20);		//接收数据数组
unsigned char	R_count;					//需要发送的数据个数
unsigned  char in_R_count;					//能够每次接收N个数据的次数
unsigned  char co_R_count;					//剩余待发数据需要N=1，时发送
unsigned  char su_R_count;					//接收N=1发送的数据存储的首地址
const char N_Count = 4;						//CxNT设置值
#define	N 		4;							//CxNT设置值

//=============================================================================
//********************************程序主函数***********************************
//=============================================================================
void main(void)					  		//程序主函数
{
	SYSTEM_INIT();						//系统初始化
	I2C_Master_INIT();
	while(1)
	{
		CLRWDT();					  	//清除看门狗
		I2C_Master_Write();
		Delay();
		R_count = 18;
		in_R_count = (R_count)/N;
		co_R_count = (R_count)%N;
		su_R_count = R_count-co_R_count;	
		Delay();
		Delay();
		I2C_Master_Read();
		Delay();
		Delay();			
	}
}
//=============================================================================
//******************************中断服务子程序*********************************
//高优先级中断入口需调用空函数做断点保护
//注：中断处理调用子函数处理，不要再这里直接处理
//=============================================================================
void interrupt high_priority Intr(void)
{
	#asm
		call  _breakpoint_protect,f
	#endasm

}
//=============================================================================
//**********************************空函数*************************************
//空函数做断点保护
//用户不可更改
//=============================================================================
void breakpoint_protect()
{

}


//=============================================================================
//*******************************I2C主机初始化*********************************
;//端口设置：端口IOF5（数据线SDA0）、IOF6（时钟线SCL0）设为输出模式，开启上拉
;//I2C主机设置：开启I2C模块，作为主机，作为主机，主机不需设置本机地址
//=============================================================================
void I2C_Master_INIT(void)
{
//1、端口初始化
	PUF5=0;				//SDA0
	OEF5=0;
	PUF6=0;				//SCL0
	OEF6=0;
	ANSF5=0;
	ANSF5=0;
//2、I2C主机设置
	I2C0CR1 = 0x88;
	I2C0CR2 = 0x20;
	I2C0PRESC=0x07;
}
//-------------------------------------------
//延时
void Delay(void)
{
	unsigned char i;
	unsigned char j;
	for(i=10;i>0;i--)
	{
		for(j=50;j>0;j--);
	}
}
//===============================================================================
//*********************************I2C主机写*************************************
//主机向从机发送四个数据，第一个数据为要写入RAM区的地址；在从机RAM的0x20处分别写
//  入0x55、0xAA、0xFF
//===============================================================================		
void I2C_Master_Write(void)
{
	I2C0DBUF=0xA0;					//发送从机的器件地址
	I2C0DBUF=0x20;					//发送要读的RAM区地址
	C0SR=1;							//起始信号，注：这里要先写buf
	while(C0BF==0);					//等待起始信号发送完成

/* 	I2C_Send_Data(0x55);		//	发送数据
	I2C_Send_Data(0xAA);
	I2C_Send_Data(0xFF); */
	I2C0DBUF=0x55;
	I2C0DBUF=0xAA;
	I2C_Send_Data(0xFF);

	I2C_Send_Data(0x11);		//	发送数据
	I2C_Send_Data(0x22);
	I2C_Send_Data(0x33);

	I2C_Send_Data(0x44);		//	发送数据
	I2C_Send_Data(0x55);
	I2C_Send_Data(0x66);
	
	I2C_Send_Data(0x77);		//	发送数据
	I2C_Send_Data(0x88);
	I2C_Send_Data(0x99);	


	C0SP=1;						//停止信号
}
//===============================================================================
//*********************************I2C发送数据***********************************
//===============================================================================		
void I2C_Send_Data(unsigned char R_Data)
{
	I2C0DBUF=R_Data;
	while(C0BF==0);
}

//===============================================================================
//*********************************I2C主机读*************************************
//主机先发送要读出RAM区的地址，再读数据在主机RAM区0x20开始写入数据
//===============================================================================	
void I2C_Master_Read(void)
{
	unsigned char i,j,k;
	C0ACK=0;						//注：软件清除CxACK位主机继续读传输
//发送要读出的地址	
	I2C0DBUF=0xA0;
	I2C0DBUF=0x20;					//发送要读的RAM区地址
	C0SR=1;							//起始信号，注：这里要先写buf
	while(C0BF==0);					//等待起始信号发送完成
//发送地址读
	C0SR=1;							//注：这里要先写起始信号
	I2C_Send_Data(0xA1);			//发送地址读
	I2C0DBUF=0;						//注：写一下buf,清除CxBF标志
	C0NT1 = 1;
	C0NT0 = 1;						//接收数据时将N写为4
	
//读数据
	for(i=1;i<=in_R_count;i++)	    //读取N的整数倍数据
	{
		while(C0BF==0);
		for(j=0;j<N_Count;j++)
		{
			IIC_RBUF[N_Count*(i-1)+j] = I2C0DBUF;
		}
	}
 	C0NT1 = 0;						//剩余非N的整数倍的数据通过设置N=1时，读取
	C0NT0 = 0;	
	for(k=0;k<co_R_count;k++)
	{
		while(C0BF==0);
		IIC_RBUF[su_R_count+k] = I2C0DBUF;
	}
	C0ACK=1;
	while(C0BF==0);					//注：设置了停止读后，实际还会有一次读时钟，该数舍去
	R_Temp = I2C0DBUF;				//注：读buf,清除CxBF标志	
	C0SP=1;							//停止信号	
	while(C0SP==1);					//注：等待发送完停止信号	
	
}
//=============================================================================
//*********************************系统初始化**********************************
//系统时钟初始化：快钟、慢钟都正常工作，不进休眠
//IO初始化:设置个IO状态为输出低，且关闭上下拉
//中断总开关：关闭总开关
//=============================================================================	
void SYSTEM_INIT(void)
{
//----------------------------------------------------
//Init Clock
	OSCM = 0x00;
//----------------------------------------------------	            
//Init IO
	//IOA
	ANSA = 0x00;               //0:数字口	1:模拟口 
	PUA = 0x00;                //0:上拉关闭 1:上拉使能
	PDA = 0x00;				   //0:下拉关闭 1:下拉使能
	IOA = 0x00;                //IO口数据
	OEA = 0xFF;                //0:输入 1:输出
	//IOB
	ANSB = 0x00;
	PUB = 0x00;
	PDB = 0x00;
	IOB = 0x00;
	OEB = 0xFF;
	//IOC
	ANSC = 0x00;
	PUC = 0x00;
	PDC = 0x00;
	IOC = 0x00;
	OEC = 0xFF;
	//IOD
	ANSD = 0x00;
	PUD = 0x00;
	PDD = 0x00;
	IOD = 0x00;
	OED = 0xFF;
	//IOE
	ANSE = 0x00;
	PUE = 0x00; 
	PDE = 0x00;
	IOE = 0x00;
	OEE = 0xFF;
	//IOF
	ANSF = 0x00;
	PUF = 0x00;
	PDF = 0x00;
	IOF = 0x00;
	OEF = 0xFF;
//----------------------------------------------------     
//Init Interrupt
	GIEL = 0;                  //1:全局中断低优先级中断使能,0:屏蔽全局中断低优先级中断
	GIEH = 0;                  //1:全局中断高优先级中断使能,0:屏蔽全局中断高优先级中断
}

//*********************************END OF FILE**********************************